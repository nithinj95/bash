#!/bin/sh

######################################################################
# Filename: suse_dc_tool.sh
# Version: 4.0
# Description: UNIX Tool to capture system information
#              and list installed software from UNIX systems
# 
# Platforms Supported: SUSE Linux
######################################################################

######################################################################
# NOTICE:
# THIS SCRIPT IS PROVIDED 'AS IS' AND IS MEANT TO ACT AS AN
# ILLUSTRATIVE EXAMPLE ONLY. CUSTOMER IS RESPONSIBLE FOR TESTING AND
# EVALUATING THE EFFECTIVENESS OF THIS SCRIPT. ANY EXPRESSED OR
# IMPLIED WARRANTIES ARE DISCLAIMED. IN NO EVENT SHALL SUSE
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SCRIPT, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
######################################################################

#####################
## Parameter Override
#####################
## Uncomment the following line to supply overriding command-line parameters to the tool
#OVERRIDE=""

if [ $# -gt 0 ]; then
  if [ $1 = "OVERRIDE" ]; then
    shift
    echo "Executing with the following pre-configured parameters: $0 $@"
  elif [ "x$OVERRIDE" != x ]; then
    $0 OVERRIDE $OVERRIDE
    exit
  fi 
elif [ "x$OVERRIDE" != x ]; then
  $0 OVERRIDE $OVERRIDE
  exit
fi

########################################################################
## Remote Script Parameter - do not alter the following line in any way!
## REMOTE_OPTIONS
########################################################################

############
## Functions
############

check_root() {
##
# This function checks that the tool is being run as root user.
##
  [ `${ID} |${SED} -e 's/uid=//' -e 's/(.*//'` = "0" ] || {
    if [ $INIT_NR = "Y" ]; then
      ${CAT} <<EOF

WARNING!!! The tool is not running as the 'root' user. 
Script output may be incomplete - additional audit procedures may be required. 
Whenever possible, please run the tool as 'root'.

EOF
    else  
      ${CAT} <<EOF

WARNING!!! Needs to be run as the 'root' user.  Script terminating.

EOF
      exit 1
    fi
  }
}

clean_up() {
##
# This function removes the output directories when called.
##
  if [ -d ${OUTDIR} ]; then
    ${PRINTF} "\nRemoving output directory: ${OUTDIR}\n\n"
    ${RM} -rf ${OUTDIR}
    [ -f ${OUTDIR}.tar ] && ${RM} -f ${OUTDIR}.tar
    [ -f ${OUTDIR}.tar.gz ] && ${RM} -f ${OUTDIR}.tar.gz
    [ -f ${OUTDIR}.tar.zip ] && ${RM} -f ${OUTDIR}.tar.zip
    [ -f ${OUTDIR}.tar.Z ] && ${RM} -f ${OUTDIR}.tar.Z
  else
    ${PRINTF} "\nCleanup complete - ${OUTDIR}\n\n"
  fi
}

create_out_dir() {
##
# This function creates an directory for the outputs generated by the tool.
##
  [ -d ${OUTDIR} ] && mv ${OUTDIR} ${OUTDIR}.`date +%H%M.%S`
  ${MKDIR} ${OUTDIR}

  ${TOUCH} ${ERRFILE}
  if [ \! -w ${ERRFILE} ]; then
  ${CAT} <<EOF
Error creating output file.
$0 is terminating.
EOF
  exit 1
  fi

  xml_write open log logscan
  ${ECHO} "${HOSTNAME} ${DATE}: Initialization completed"
}

defcmd() {
##
# Syntax: defcmd UPPERCMD lowercmd [critical|silent]
# This function searches in /bin, /user/bin, then PATH for the required commands. Critical commands not found results in tool termination.
##
  UPPERCMD=$1; LOWERCMD=$2 SEVERITY=${3:-functional}

  for i in /bin /usr/bin /sbin; do
    if [ -x $i/$LOWERCMD ]; then
      eval $UPPERCMD=$i/$LOWERCMD
      return
    fi
  done

  if `which $LOWERCMD 2>&1 | ${GREP} "no $LOWERCMD" >/dev/null`; then
    ${TRUE}
  else
    eval $UPPERCMD=`which $LOWERCMD`
    return
  fi

  if [ $SEVERITY = "critical" ]; then
    ${ECHO} "CRITICAL WARNING - $LOWERCMD missing!!! This tool will terminate."
    TERMINATE=1
  elif [ $SEVERITY = "silent" ]; then
    ${TRUE}
  else
    echo "WARNING - $LOWERCMD missing!!! All functionality of the tool may not be available."
  fi
}

extract() {
##
# Syntax: extract filename begin-match end-match
# This function is used for the extraction of matching directories.
##
  X_FILENAME=$1
  X_BEGINMATCH=$2
  X_ENDMATCH=$3

  OUTLOUD=0
  ${CAT} $X_FILENAME | while read i
  do
    `${ECHO} $i | ${GREP} "$X_BEGINMATCH" >/dev/null 2>&1` && OUTLOUD=1 
    `${ECHO} $i | ${GREP} "$X_ENDMATCH" >/dev/null 2>&1` && OUTLOUD=0
    [ $OUTLOUD = "1" ] && ${ECHO} $i 
  done
}

get_os() {
##
# This function is used to collect operating system name and release from 'UNAME' command.
##
  OS=`${UNAME} -s 2>/dev/null`
  OS_RELEASE=`${UNAME} -r 2>/dev/null`
  if [ ${OS} = "SunOS" ]; then
    [ `${UNAME} -r | ${CUT} -c1` -eq 5 ] && OS="Solaris"
  fi
  if [ ${OS} = "OSF1" ]; then
    OS="Solaris"
  fi
  if [ ${OS} = "Linux" ]; then
    RELEASE=`cat /etc/*-release 2>/dev/null | head -1`
    DISTRIBUTION=`lsb_release -i`
  else
    RELEASE=""
  fi
}

grab() {
##
# Syntax: grab [tag tagname] [msg 'message to be displayed'] outfile 'command ...'
# This function is used by other functions.
##
  if [ $1 = "tag" ]; then
    shift; GRAB_TAG="$1"; shift
  else
    GRAB_TAG="none"
  fi

  if [ $1 = "msg" ]; then
    shift; GRAB_MESSAGE="$1"; shift
  else
    GRAB_MESSAGE="none"
  fi

  GRAB_ERRTAG="$1"
  GRAB_OUTFILE="${OUTDIR}/${PREFIX}.$1.txt"; shift
  GRAB_COMMAND="$@"

  [ ! "$GRAB_MESSAGE" = "none" ] && ${PRINTF} "${HOSTNAME} ${DATE}: ${GRAB_MESSAGE} ... "

  ${ECHO} "<$GRAB_ERRTAG>" >>${ERRFILE}
  [ ! $GRAB_TAG = "none" ] && ${ECHO} "<$GRAB_TAG>" >>${GRAB_OUTFILE}
  eval ${GRAB_COMMAND} >>${GRAB_OUTFILE} 2>>${ERRFILE}
  RETURNCODE=$?
  [ ! $GRAB_TAG = "none" ] && ${ECHO} "</$GRAB_TAG>" >>${GRAB_OUTFILE}
  ${ECHO} "</$GRAB_ERRTAG>" >>${ERRFILE}

  if [ $RETURNCODE = "0" ]; then
    [ ! "$GRAB_MESSAGE" = "none" ] && ${ECHO} "done." 
  else
    [ ! "$GRAB_MESSAGE" = "none" ] && ${ECHO} "failed." 
  fi
}

grab_software() {
##
# This function collects the software package listing depending on operating system.
##
  grab msg 'Listing software (rpm) packages' linux.software '/bin/rpm -qa --qf "%{NAME}|%{VERSION}|%{RELEASE}|%{INSTALLTIME}|%{VENDOR}|%{BUILDTIME}|%{BUILDHOST}|%{SOURCERPM}|%{LICENSE}|%{PACKAGER}|%{DISTRIBUTION}\n"'
  if [ -d /etc/products.d ]; then
    ls -1 /etc/products.d|while read i
    do
      grab msg "Collecting installed product information for $i" linux.$i "cat /etc/products.d/$i"
    done
  fi
  grab tag zypphistory msg 'Collecting zypp history' linux.zypphistory "cat /var/log/zypp/history"
  # Included zypper lr command output to list all zypp repository
  grab tag zypprepos msg 'Collecting zypp repos' linux.zypprepos zypper --no-refresh -x lr --details
  # Included zypper se command output to list all zypp packages
  grab tag zypppackages msg 'Collecting zypp packages' linux.zypppackages zypper --no-refresh -x se -i
  # Included zypper patterns command to show installed patterns
  grab tag zypppatterns msg 'Collecting zypp patterns' linux.zypppatterns zypper --no-refresh -x patterns -i
  # Included zypper patterns command to show installed products
  grab tag zypppatterns msg 'Collecting zypp patterns' linux.zyppproducts zypper --no-refresh -x pd
}

grab_sysinfo() {
##
# This function collects system hardware information depending on operating system.
##
  grab tag dmidecode linux.dmidecode /usr/sbin/dmidecode
  grab tag arch linux.arch /bin/arch

  echo "<linux.rawdmi>" >> ${ERRFILE}

  # The following is an alternative hardware data collection method.
  #      DMIDIR=$(find /sys -name dmi|head -1)
  #      echo "<linux.rawdmi $DMIDIR>" >> ${OUTDIR}/${PREFIX}.linux.rawdmi.txt
  #     find $DMIDIR -type f|while read i
  #     do
  #       ( printf "${i##$DMIDIR/id/}\t: "; cat $i )
  #      done >> ${OUTDIR}/${PREFIX}.linux.rawdmi.txt 2>>${ERRFILE}
  #      printf "\n</linux.rawdmi>\n" >> ${OUTDIR}/${PREFIX}.linux.rawdmi.txt
  echo "</linux.rawdmi>" >> ${ERRFILE}

  grab tag cpuinfo linux.cpuinfo cat /proc/cpuinfo

  # Included spident and sam command output to list SUSE supportability
  # grab tag spident msg 'Checking SLES 10 supportability' linux.spident spident -v
  # grab tag sam msg 'Checking SLES 11 supportability' linux.sam sam

  if [ -x /usr/sbin/xm ]; then
    grab tag xminfo linux.xminfo /usr/sbin/xm info
    grab tag xmlist linux.xmlist /usr/sbin/xm list
  fi

  if [ -x /usr/sbin/xe ]; then
    grab tag xevmlist linux.xevmlist /usr/sbin/xe vm-list
    grab tag xehostlist linux.xehostlist /usr/sbin/xe host-list
  fi
}

print_notice() {
  ${CAT} <<EOF
THIS SCRIPT IS PROVIDED 'AS IS' AND IS MEANT TO ACT AS AN
ILLUSTRATIVE EXAMPLE ONLY. CUSTOMER IS RESPONSIBLE FOR TESTING AND
EVALUATING THE EFFECTIVENESS OF THIS SCRIPT. ANY EXPRESSED OR
IMPLIED WARRANTIES ARE DISCLAIMED. IN NO EVENT SHALL SUSE
 BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SCRIPT, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

EOF
}

print_version() {
  ${CAT} <<EOF

`${HEAD} -5 $0 | ${TAIL} -3 | ${SED} -e 's/#//'`

EOF
}

remote_script() {
##
# This function is called when the remote execution flag is used.
##
  REMOTE_HOSTS=${1:-invalid_file}
  if [ ! -r $REMOTE_HOSTS ]; then
    ${PRINTF} "ERROR: Remote hosts file specified is not readable! Script terminating.\n\n"
    exit 1
  fi
  ${CAT} $REMOTE_HOSTS | ${GREP} "^[^#]" | while read i
  do
    R_ADDRESS=`${ECHO} $i|${AWK} '{print $1}'`
    R_USERTMP=`${ECHO} $i|${AWK} '{print $2}'`
    R_USER=${R_USERTMP:-root}
    R_OPTIONS=`${ECHO} $i|${AWK} '{print $3" "$4" "$5" "$6}'`
    R_LASTFILE=`${LS} -1t *.output.tar* 2>&1 | ${HEAD} -1`
    ${ECHO} "Connecting to remote host: $R_ADDRESS as user: '$R_USER' ..."
    ${CAT} $0 | ${SED} -e "s/^## REMOTE_OPTIONS$/REMOTE_OPTIONS=\"$R_OPTIONS\"/" | ${SSH} ${R_USER}@${R_ADDRESS} 'sh - 1>&2 ;\
                                               tar -cf - `hostname`.`date +%m.%d.%Y`.output.tar* ;\
                                               rm -rf `hostname`.`date +%m.%d.%Y`.output 1>&2 ;\
                                               rm -f  `hostname`.`date +%m.%d.%Y`.output.tar* 1>&2' | \
                                               ${TAR} -xf - 2>/dev/null
    R_SAVEDFILE=`${LS} -1t *.output.tar* 2>&1 | ${HEAD} -1`
    [ ! "$R_LASTFILE" = "$R_SAVEDFILE" ] && ${ECHO} "Output saved to local disk as: $R_SAVEDFILE"
    ${ECHO} ""
  done
  exit 0
}

usage() {
#Basic flags 
  usage_basic
  usage_footer
  print_notice
}

usage_advanced() {
#Advanced flags
  usage_basic
  usage_more
  usage_footer
  print_notice
}

usage_basic() {
  ${CAT} <<EOF

Usage: $0 [options]

  [-y|--yes]      Continue running the tool without waiting
  [-v|--version]  Print version and exit
  [-h|--help]     Print this usage message
  [-m|--morehelp] Print usage message with advanced options
  [-c|--clean]    Delete output files

EOF
}

usage_more() {
  ${CAT} <<EOF
  [-nr|--noroot]  Run as a non-root user
  [-i|--include] [ sys|cpu | sw|software ]
  [-e|--exclude] [ sys|cpu | sw|software ]
    Selectively include or exclude one of the following:
      sys, cpu     : System information relating to CPU
      sw, software : Software packages information and IBM software output
    Example: '$0 -e sw' excludes software package information 
             from being collected 
             '$0 -i sys' only collects CPU information

  [-r|--remote] remotelist
    Remotely execute this tool on remote hosts listed in file 'remotelist'

EOF
}

usage_footer() {
  ${CAT} <<EOF
This tool collects information about installed packages and system information on the host,
then packages it into a tar file, compressed if available.

EOF
}

wrap_up() {
##
# This function attempts to compress all directories created by the tool and prints a completion message.
##
  #${ECHO} "<tar>" >>${ERRFILE}
  xml_write close log logscan
    [ -f ${OUTDIR}.tar ] && mv ${OUTDIR}.tar ${OUTDIR}.`date +%H%M.%S`.tar
    [ -f ${OUTDIR}.tar.gz ] && mv ${OUTDIR}.tar.gz ${OUTDIR}.`date +%H%M.%S`.tar.gz
    [ -f ${OUTDIR}.tar.zip ] && mv ${OUTDIR}.tar.zip ${OUTDIR}.tar.`date +%H%M.%S`.zip
    [ -f ${OUTDIR}.tar.Z ] && mv ${OUTDIR}.tar.Z ${OUTDIR}.`date +%H%M.%S`.tar.Z
    ${TAR} -cf ${OUTDIR}.tar ${OUTDIR} 2>>${ERRFILE}
    ( gzip ${OUTDIR}.tar || \
      zip -Tm ${OUTDIR}.tar.zip ${OUTDIR}.tar >>${ERRFILE} || \
      compress ${OUTDIR}.tar || \
      ${TRUE} ) 2>>${ERRFILE}
  ${ECHO} "</tar>" >>${ERRFILE}
  [ -f ${OUTDIR}.tar* ] && rm -rf ${OUTDIR}
  ${ECHO} "${HOSTNAME} ${DATE}: Execution completed"
}

xml_write() {
##
# Syntax: xml_write (open|qopen|add|label|close) [-l(number)] outfile tagname value
# This function is used internally by other functions.
##
  XML_ACTION=$1; shift

  SPACER=""
  if `${ECHO} $1|${GREP} "^-l" >/dev/null 2>&1`; then
    SPACEVAL=`${ECHO} $1|${SED} -e 's/-l//'`
    while [ $SPACEVAL -gt 0 ];
    do
      SPACER="${SPACER}  "
      SPACEVAL=`${EXPR} ${SPACEVAL} - 1`
    done
    shift
  fi

  XML_FILE=${OUTDIR}/${PREFIX}.${1}.txt; shift
  XML_TAG="$1"; shift

  case ${XML_ACTION} in
    'open')
      ${CAT} <<EOF >${XML_FILE}
<${XML_TAG}>
  <script>
    <name>$0</name>
    <parameters>$PARAMS</parameters>
    <version>`${HEAD} $0 2>/dev/null|${GREP} "Version:"|${AWK} -F": " '{print $2}'|${SED} -e 's/^ *//'`</version>
    <user>`${ID}`</user>
  </script>
  <hostname>${HOSTNAME}</hostname>
  <scandate>`${DATE_CMD} +%m-%d-%Y`</scandate>
  <os>
    <name>${OS}</name>
    <version>${OS_RELEASE}</version>
    <release>${RELEASE}</release>
  </os>
EOF
    ;;
    'qopen')
      ${ECHO} "<${XML_TAG}>" >${XML_FILE}
    ;;
    'label')
#  XML_VALUE must be 'open' or 'close'      
      XML_VALUE="$@"
      [ $XML_VALUE = "open" ] && ${ECHO} "${SPACER}<${XML_TAG}>" >>${XML_FILE}
      [ $XML_VALUE = "close" ] && ${ECHO} "${SPACER}</${XML_TAG}>" >>${XML_FILE}
    ;;
    'add')
      XML_VALUE="$@"
      ${ECHO} "${SPACER}<${XML_TAG}>${XML_VALUE}</${XML_TAG}>" >>${XML_FILE}
    ;;
    'close')
      ${ECHO} "</${XML_TAG}>" >>${XML_FILE}
    ;;
    *)
      ${TRUE}
    ;;
  esac
}

initialize_commands() {
##
# Pre-initialize normal commands
##
  TERMINATE=0
    defcmd AWK awk
    defcmd BASENAME basename
    defcmd BC bc silent
    defcmd BINDPROCESSOR bindprocessor silent
    defcmd CUT cut critical
    defcmd DMESG dmesg silent
    defcmd DD dd
    defcmd EXPR expr
    defcmd FIND find
    defcmd ID id critical
    defcmd IFCONFIG ifconfig
    defcmd LS ls critical
    defcmd MKDIR mkdir critical
    defcmd NETSTAT netstat
    defcmd PS ps
    defcmd SSH ssh
    defcmd SORT sort
    defcmd STTY stty
    defcmd TAR tar
    defcmd TOUCH touch critical
    defcmd TR tr
    defcmd TRANSFER_CMD scp
    defcmd UNAME uname critical
    defcmd UNIQ uniq
    defcmd WC wc
  [ $TERMINATE -eq 1 ] && exit 1
}

TERMINATE=0
##
# Pre-initialize critical commands
##
  defcmd CAT cat critical
  defcmd DATE_CMD date critical
  defcmd ECHO echo critical
  defcmd GREP grep critical
  defcmd HEAD head critical
  defcmd HOSTNAME_CMD hostname critical
  defcmd PRINTF printf critical
  defcmd RM rm critical
  defcmd SED sed critical
  defcmd TAIL tail critical
  defcmd TRUE true critical
[ $TERMINATE -eq 1 ] && exit 1


PARAMS=$@
##
# Define variables for internal use.
##

TRANSFER_HOST=''
TRANSFER_USER=''

HOSTNAME=`${HOSTNAME_CMD}`; HOSTNAME=${HOSTNAME:-unknown}
DATE=`${DATE_CMD} +%m.%d.%Y`

PREFIX="${HOSTNAME}.${DATE}"
OUTDIR="${PREFIX}.output"
ERRFILE="${OUTDIR}/${PREFIX}.log.txt"


if [ $0 = "sh" ]; then
	##
	# Remote execution logic
	##
	initialize_commands
	get_os
	PARAMS="$REMOTE_OPTIONS"
	DO_SYS=0; DO_PKG=0
	for i in `${ECHO} $REMOTE_OPTIONS`; do
		[ $i = "sys" ] && DO_SYS=1
		[ $i = "sw" ] && DO_PKG=1
	done
	[ $DO_SYS -eq 0 -a $DO_PKG -eq 0 ] && {
		DO_SYS=1; DO_PKG=1
	}
	create_out_dir && {
		[ $DO_SYS = "1" ] && grab_sysinfo
		[ $DO_PKG = "1" ] && grab_software
		wrap_up
	}
	exit 0
fi

##
# Local execution logic
# Parse input variables
##
INIT_V="N"
INIT_H="N"
INIT_M="N"
INIT_C="N"
INIT_Y="N"
INIT_NR="N"
INIT_R="N"; INIT_R_PARAM=""
INIT_I="N"; INIT_I_PARAM=""
INIT_E="N"; INIT_E_PARAM=""
INIT_ERR="N"

while [ $# -gt 0 ]; do
  case $1 in
    '-v'|'--version')
      INIT_V="Y"; shift
    ;;
    '-h'|'--help')
      INIT_H="Y"; shift
    ;;
    '-m'|'--morehelp')
      INIT_M="Y"; shift
    ;;
    '-c'|'--clean')
      INIT_C="Y"; shift
    ;;
    '-y'|'--yes')
      INIT_Y="Y"; shift
    ;;
    '-i'|'--include')
      INIT_I="Y"; shift
      INIT_I_PARAM="$INIT_I_PARAM $1"; shift
    ;;
    '-e'|'--exclude')
      INIT_E="Y"; shift
      INIT_E_PARAM="$INIT_E_PARAM $1"; shift
    ;;
    '-nr'|'--noroot')
      INIT_NR="Y"; shift
    ;;
    '-r'|'--remote')
      INIT_R="Y"; shift
      INIT_R_PARAM="$1"; shift
    ;;
    *)
      INIT_ERR="Y"; shift
    ;;
  esac
done

##
# The following parameters cause the tool to exit after a single action is taken
##
[ $INIT_R = "Y" ] && {
  initialize_commands
  remote_script $INIT_R_PARAM
  exit 0
}
[ $INIT_ERR = "Y" ] && {
  echo
  echo "Error: Invalid parameter entered."
  usage; exit
}
[ $INIT_H = "Y" ] && { 
  usage; exit 
}
[ $INIT_M = "Y" ] && {
  usage_advanced; exit
}
[ $INIT_V = "Y" ] && {
  print_version; exit
}
[ $INIT_C = "Y" ] && {
  clean_up; exit
}

##
# The following lines determine what gets executed if '--include' or '--exclude' parameters are supplied 
# If both -i and -e parameters are supplied, -i takes precedence and -e parameters will not be processed
##
if [ $INIT_I = "Y" ]; then
  DO_SYS=0; DO_PKG=0
  for i in `echo $INIT_I_PARAM`; do
    [ $i = "sys" -o $i = "cpu"      ] && DO_SYS=1
    [ $i = "sw"  -o $i = "software" ] && DO_PKG=1
  done
  INIT_Y="Y"
elif [ $INIT_E = "Y" ]; then
  DO_SYS=1; DO_PKG=1
  for i in `echo $INIT_E_PARAM`; do
    [ $i = "sys" -o $i = "cpu"      ] && DO_SYS=0
    [ $i = "sw"  -o $i = "software" ] && DO_PKG=0
  done
  INIT_Y="Y"
else
  DO_SYS=1; DO_PKG=1
fi 

##
# Actual execution steps
##
usage
initialize_commands

[ $INIT_Y = "N" ] && {
  ${PRINTF} "Press 'Q', [Enter] or [Space] to EXIT, any other key to execute the tool ..."
    OLDSTTY=`${STTY} -g`
    ${STTY} -icanon -echo min 1 time 0
    RESPONSE=`${DD} bs=1 count=1 2>/dev/null`
    ${STTY} $OLDSTTY
  if [ $RESPONSE ] && [ ! $RESPONSE = "Q" ] && [ ! $RESPONSE = "q" ]; then
    ${ECHO} ""
  else
    ${ECHO} ""
    exit 0
  fi
}

get_os
check_root && create_out_dir && {
  [ $DO_SYS = "1" ] && grab_sysinfo
  [ $DO_PKG = "1" ] && grab_software
  wrap_up
}
